#!/usr/bin/env python

# Copyright 2017 DIANA-HEP
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import glob
import os
import math

import fastavro
from plur.types import *
from plur.python.data import toarrays
from plur.python.filldisk import FillableOnDisk

def convertschema(avroschema):
    names = {}
    def findnames(x):
        if isinstance(x, dict):
            if x["type"] == "record":
                for field in x["fields"]:
                    findnames(field["type"])

                if "namespace" in x:
                    names[x["namespace"] + "." + x["name"]] = x
                else:
                    names[x["name"]] = x

            elif x["type"] == "array":
                findnames(x["items"])

    findnames(avroschema)

    def recurse(x):
        if isinstance(x, dict):
            if x["type"] == "record":
                out = {}
                for field in x["fields"]:
                    out[field["name"]] = recurse(field["type"])
                return Record(**out)

            elif x["type"] == "array":
                return List(recurse(x["items"]))

            elif x["type"] == "boolean":
                return boolean

            elif x["type"] == "int":
                return int32

            elif x["type"] == "long":
                return int64

            elif x["type"] == "float":
                return float32

            elif x["type"] == "double":
                return float64

            else:
                raise NotImplementedError("not yet handling Avro schema type {0}".format(x["type"]))

        else:
            return recurse(names[x])

    return recurse(avroschema)

if __name__ == "__main__":
    argparser = argparse.ArgumentParser()
    argparser.add_argument("files", nargs="+")
    argparser.add_argument("--schema", action="store_true", default=False)
    argparser.add_argument("--start", type=int, default=0)
    argparser.add_argument("--skip", type=int, default=1)
    argparser.add_argument("--directory", default=".")
    args = argparser.parse_args()

    filenames = [y for x in args.files for y in sorted(glob.glob(os.path.expanduser(x)))]

    avroschema = fastavro.reader(open(filenames[0], "rb")).schema

    plurtype = List(convertschema(avroschema))

    if args.schema:
        print(formattype(plurtype))

    formatter = "{0:0" + str(int(math.ceil(math.log(len(filenames), 10)))) + "d}"

    for index, filename in list(enumerate(filenames))[args.start::args.skip]:
        partitiondir = os.path.join(os.path.expanduser(args.directory), formatter.format(index))

        if not os.path.exists(partitiondir):
            os.mkdir(partitiondir)

        if not os.path.isdir(partitiondir):
            raise IOError("{0} is not a directory".format(partitiondir))

        toarrays("events", fastavro.reader(open(filename, "rb")), plurtype, FillableOnDisk, directory=partitiondir)
