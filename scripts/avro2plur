#!/usr/bin/env python

# Copyright 2017 DIANA-HEP
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import glob
import os
import math

import fastavro
from plur.types import *
from plur.python.data import toarrays
from plur.python.filldisk import FillableOnDisk

def convertschema(avroschema):
    names = {}
    def findnames(x):
        if isinstance(x, dict):
            if x["type"] == "record":
                for field in x["fields"]:
                    findnames(field["type"])

                if "namespace" in x:
                    names[x["namespace"] + "." + x["name"]] = x
                else:
                    names[x["name"]] = x

            elif x["type"] == "array":
                findnames(x["items"])

    findnames(avroschema)

    def recurse(x):
        if isinstance(x, dict):
            if x["type"] == "record":
                out = {}
                for field in x["fields"]:
                    out[field["name"]] = recurse(field["type"])
                return Record(**out)

            elif x["type"] == "array":
                return List(recurse(x["items"]))

            elif x["type"] == "boolean":
                return boolean

            elif x["type"] == "int":
                return int32

            elif x["type"] == "long":
                return int64

            elif x["type"] == "float":
                return float32

            elif x["type"] == "double":
                return float64

            else:
                raise NotImplementedError("not yet handling Avro schema type {0}".format(x["type"]))

        else:
            return recurse(names[x])

    return recurse(avroschema)

if __name__ == "__main__":
    argparser = argparse.ArgumentParser(epilog="To divide the work among N avro2plur processes, set --procn to N for all processes and --proci to an index from 0 up to N for each process. They will divide the input files roughly equally. (Be sure to give all processes exactly the same set of files!)")
    argparser.add_argument("files", nargs="+", help="Avro files on the local filesystem to convert; may include wildcards.")
    argparser.add_argument("--schema", action="store_true", default=False, help="Print out the converted PLUR schmea.")
    argparser.add_argument("--proci", type=int, default=0, metavar="i", help="See below.")
    argparser.add_argument("--procn", type=int, default=1, metavar="N", help="See below.")
    argparser.add_argument("--limit", default=None, help="Maximum number of entries to convert per file.")
    argparser.add_argument("--prefix", default="data", help="Prefix for column names.")
    argparser.add_argument("--columns", default=None, help="Filter on columns to generate; a Python function on 'name' (plur.types.arrayname.ArrayName).")
    argparser.add_argument("--fillnan", action="store_true", default=False, help="Fill numeric quantities with NaN (floating point) or MAXINT (integer) if out of numerical range.")
    argparser.add_argument("--directory", default=".", help="Directory for output directories.")
    args = argparser.parse_args()

    if args.limit is not None:
        args.limit = int(args.limit)

    if args.columns is None:
        args.columns = lambda name: True
    else:
        args.columns = eval("lambda name: " + args.columns)

    filenames = [y for x in args.files for y in sorted(glob.glob(os.path.expanduser(x)))]

    avroschema = fastavro.reader(open(filenames[0], "rb")).schema

    plurtype = List(convertschema(avroschema))

    if args.schema:
        print(formattype(plurtype))

    formatter = "{0:0" + str(int(math.ceil(math.log(len(filenames), 10)))) + "d}"

    for index, filename in list(enumerate(filenames))[args.proci::args.procn]:
        partitiondir = os.path.join(os.path.expanduser(args.directory), formatter.format(index))

        if not os.path.exists(partitiondir):
            os.mkdir(partitiondir)

        if not os.path.isdir(partitiondir):
            raise IOError("{0} is not a directory".format(partitiondir))

        iterator = fastavro.reader(open(filename, "rb"))
        if args.limit is not None:
            def generator(iterator):
                for i, x in enumerate(iterator):
                    if i >= args.limit: break
                    yield x
            iterator = generator(iterator)

        toarrays(args.prefix, iterator, plurtype, FillableOnDisk, lambda n: args.columns(n), args.fillnan, directory=partitiondir)
